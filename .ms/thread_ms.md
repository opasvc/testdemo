# Java线程都有哪些状态

<p>
在java里边对线程做了6种状态的划分，首先是
</p>
<ol>
    <li>
        NEW: new状态就是线程刚创建，但是还没有调用start方法去启动
    </li>
    <li>
        RUNNABLE：运行状态，线程已经启动，但是没有获得cpu资源，处于等待状态
    </li>
    <li>
        BLOCKED：阻塞状态，线程已经启动，但是没有获得cpu资源，处于等待状态
    </li>
    <li>
        WAITING：等待状态，线程已经启动，但是没有获得cpu资源，处于等待状态
    </li>
    <li>
        TIMED_WAITING：超时等待状态，线程已经启动，但是没有获得cpu资源，处于等待状态。 sleep方法就是属于这个状态
    </li>
    <li>
        TERMINATED：终止状态，线程已经结束
    </li>
</ol>

# wait和black的区别

wait是Object的方法，black是Thread的方法。<br/>
wait是让当前线程等待，black是让当前线程阻塞。<br/>
触发条件也不一样，wait是用户主动触发，调用wait或者park方法，然后需要调用notify或者unpark方法来唤醒。<br/>
而black是被动触发的，当线程尝试获取一个监视器锁时，发现锁被其他线程占有了，这个时候会进入blacked阻塞状态，线程会一直阻塞，直到锁被释放并成功获取锁。<br/>
然后就是对于锁的释放也不一样，线程进入waiting状态会主动释放锁，而blacked状态不会主动释放锁，是等待锁可用。<br/>
wait主要应用场景是线程之间的协作，比如说去实现‘生产者-消费者’模型、任务的调度 等等。<br/>
而blacked更多的是线程竞争资源导致的状态

# 创建线程有哪些方式？怎么新建一个线程

第一个就是继承`Thread`类重写`run()`方法，第二种就是实现`Runnable`接口，第三用线程池通过`futre`加`callable`去实现一个返回值。
在java里边现成的封装主要是由`Thread`实现的它提供了两个关方法，`start()`根`run()`。调用`start()`方法会触发底层的`native`
方法`start()`,
向操作系统申请线程资源，并等待CPU的调度，当CPU被线程调度后，会回调到`Thread`的`run()`方法，这个`run方法`里面是要去执行我们定义的任务逻辑，
因此启动现成的方式只有`Thread`的`run()`方法。所以可以同通过继承`Thread`类重写`run()`方法,将要执行的任务逻辑写道里边。
实现`Runnable`接口的`run()`方法，并且通过`Thread`
的构造函数出入进去，JVC还会对线程进一步的分装和优化，比如使用线程池来实现现成的复用但是他的底层还是调用`Thread`
类重写`run()`方法去创建线程。
也可以结合`FutureTask`和`Callable`接口来实现异步任务的执行，和返回结果的等待。
这些机制可以帮助我们更好的管理线程，提升程序的一个性能和可维护性

# 线程池如何实现线程的复用

线程池的核心就是线程复用，但是他不是通过用完以后塞回去的方式来实现的，他的关键设计原理在于线程池里维护的阻塞队列，当线程执行完一个任务已后他不会立即结束，
而是通过自旋的方式从阻塞队列里面去调用`take()`或`poll()`方法，获取新的任务，如果队列中有任务，就继续执行，执行队列里的任务，如果队列为空，
那么线程会根据线程池的配置，(比如说：核心线程数、超时时间、能否允许线程数回收等等)，来决定是否结束，具体说就是如果线程池的线程大于核心线程数，
或者设置了允许回收，且线程在指定时间内没有获取到新的任务，线程就会被回收掉如果线程池的线程数小于或等于
核心线程数，那么线程会一直阻塞等待新的任务不会被回收。
通过这种方式 线程池实现了线程的复用，避免了频繁创建和销毁线程的开销。从而提升性能

# 线程池的配置参数都有哪些

`java.util.concurrent.ThreadPoolExecutor.java`

1. 核心线程数：线程池中一直存活的线程数，即使没有任务需要执行，也会一直存活。 默认情况下，线程池中的线程数量等于当前CPU的数量。 

