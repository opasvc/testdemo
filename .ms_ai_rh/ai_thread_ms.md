# Java 线程的状态

Java 线程被划分为以下六种状态[cite: 1]:

1.  **NEW:** 线程刚被创建，尚未调用 `start()` 方法启动[cite: 1].
2.  **RUNNABLE:** 线程已经启动，可能正在运行，也可能正在等待 CPU 资源[cite: 1].
3.  **BLOCKED:** 线程已启动，但因等待获取监视器锁而被阻塞 [cite: 1, 2]。
4.  **WAITING:** 线程已启动，但正在等待其他线程执行特定操作，需要被显式唤醒 [cite: 1, 2]。
5.  **TIMED\_WAITING:** 线程已启动，正在等待其他线程执行特定操作，但等待有超时限制。例如，调用 `sleep()` 方法会使线程进入此状态[cite: 1].
6.  **TERMINATED:** 线程已执行完毕[cite: 1].

# `wait` 和 `blocked` 的区别

* `wait` 是 `Object` 类的方法，而 `blocked` 是 `Thread` 的一种状态 [cite: 2]。
* `wait` 使当前线程进入等待状态，`blocked` 使当前线程进入阻塞状态 [cite: 2]。
* `wait` 是由用户主动触发的，通过调用 `wait` 或 `park` 方法进入，需要调用 `notify` 或 `unpark` 方法来唤醒 [cite: 2]。
* `blocked` 是被动触发的，当线程尝试获取被其他线程持有的监视器锁时，会进入 `blocked` 状态，直到获取到锁 [cite: 2]。
* 线程进入 `waiting` 状态时会主动释放锁，而处于 `blocked` 状态的线程不会主动释放锁，而是等待锁可用 [cite: 2]。
* `wait` 的主要应用场景是线程之间的协作，例如实现生产者-消费者模型和任务调度等 [cite: 2]。
* `blocked` 更多的是由于线程竞争资源而产生的状态 [cite: 2]。

# 创建线程的方式

创建线程主要有以下三种方式[cite: 2]:

1.  继承 `Thread` 类并重写 `run()` 方法[cite: 2].
2.  实现 `Runnable` 接口[cite: 2].
3.  使用线程池，通过 `Future` 和 `Callable` 接口实现带返回值的线程[cite: 2].

Java 中的线程封装主要由 `Thread` 类实现，它提供了 `start()` 和 `run()` 两个关键方法[cite: 2].
调用 `start()` 方法会触发底层的 `native` 方法 `start()`，向操作系统申请线程资源并等待 CPU 调度。当线程被 CPU 调度后，会回调到 `Thread` 的 `run()` 方法，该方法包含要执行的任务逻辑[cite: 2].
因此，启动线程的方式是执行 `Thread` 的 `run()` 方法。可以通过继承 `Thread` 类并重写 `run()` 方法，或者实现 `Runnable` 接口并在 `Thread` 的构造函数中传入 `Runnable` 对象来定义任务逻辑[cite: 2].
Java 虚拟机 (JVM) 还会对线程进行进一步的封装和优化，例如使用线程池来实现线程的复用。此外，还可以结合 `FutureTask` 和 `Callable` 接口来实现异步任务的执行和结果的等待[cite: 2].
这些机制有助于更好地管理线程，提高程序的性能和可维护性[cite: 2].

# 线程池如何实现线程复用

线程池的核心在于线程复用，它并非通过用完线程后将其放回的方式实现，而依赖于线程池维护的阻塞队列[cite: 2].
线程执行完一个任务后，不会立即结束，而是通过自旋方式从阻塞队列中调用 `take()` 或 `poll()` 方法获取新任务。如果队列中有任务，线程会继续执行队列中的任务；如果队列为空，线程会根据线程池的配置（如核心线程数、超时时间、是否允许回收线程等）来决定是否结束[cite: 2].
具体来说，如果线程池中的线程数大于核心线程数，或者设置了允许回收，并且线程在指定时间内没有获取到新任务，线程就会被回收。如果线程池的线程数小于或等于核心线程数，那么线程会一直阻塞等待新任务，不会被回收[cite: 2].
通过这种方式，线程池实现了线程的复用，避免了频繁创建和销毁线程的开销，从而提升了性能[cite: 2].